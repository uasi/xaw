#include <parrot/parrot.h>
#include <libxml/HTMLparser.h>

#include "common.h"
#include "pmc_xmldoc.h"
#include "pmc_xmlnodeiter.h"
#include "pmc_xmlnode.h"


#define DATA(self) (htmlDocPtr)PMC_data(self)


BEGIN_PMC_HEADER_PREAMBLE

#include <libxml/HTMLparser.h>
PMC *HTMLDoc_new(PARROT_INTERP, htmlDocPtr doc);

END_PMC_HEADER_PREAMBLE


PMC *HTMLDoc_new(PARROT_INTERP, htmlDocPtr doc)
{
    INTVAL type = Parrot_HTMLDoc_get_vtable_pointer(interp)->base_type;
    PMC *doc_pmc = Parrot_pmc_new(interp, type);
    VTABLE_set_pointer(interp, doc_pmc, doc);
    return doc_pmc;
}


pmclass HTMLDoc
    extends XMLDoc
    dynpmc
    group libxml_group
    lib xml2
    auto_attrs {

    VTABLE void destroy() {
        htmlDocPtr ptr = DATA(SELF);
        if (ptr) {
            xmlFreeDoc(ptr);
        }
    }

    VTABLE void *get_pointer() {
        return DATA(SELF);
    }

    VTABLE void set_pointer(void *ptr) {
        PMC_data(SELF) = ptr;
    }

    VTABLE STRING *get_string() {
        htmlDocPtr ptr = DATA(SELF);
        xmlChar *buffer;
        int length;
        const char *encoding = "utf-8";
        int indent = 1;
        STRING *string;

        xmlDocDumpFormatMemoryEnc(ptr, &buffer, &length, encoding, indent);
        string = Parrot_str_new(INTERP, (char *)buffer, (UINTVAL)length);
        xmlFree(buffer);

        return string;
    }

    METHOD child() {
        htmlDocPtr ptr = DATA(SELF);
        PMC *child = PMCNULL;
        if (ptr->children) {
            child = XMLNode_new(INTERP, ptr->children);
        }
        RETURN(PMC *child);
    }

    METHOD children() {
        htmlDocPtr doc = DATA(SELF);
        PMC *iter = XMLNodeIter_new(INTERP, SELF, doc->children);
        RETURN(PMC *iter);
    }
}

// vim: expandtab shiftwidth=4 softtabstop=4
